import os
import torch
import graphviz
from torch_geometric.data import Data

########################################################################
# Ajusta estas rutas según tu caso
########################################################################
stitched_graph_file = 'batch_integrated_free/stitched_graph_0.pt'  # Data(x, edge_index)
output_folder       = 'stitched_petri_visualizations'
os.makedirs(output_folder, exist_ok=True)
########################################################################

# Carga el Petri net global
g: Data = torch.load(stitched_graph_file, map_location='cpu')

# Índices de place vs transition en x
PLACE, TRANSITION = 0, 1
node_kwargs = {
    PLACE:      dict(shape='circle',  width='0.25', height='0.25',
                     style='filled', fillcolor='#8BC34A'),
    TRANSITION: dict(shape='square',  width='0.25', height='0.25',
                     style='filled', fillcolor='#03A9F4')
}

# Calcula los nodos que participan en al menos una arista
src, dst = g.edge_index
active = set(src.tolist()) | set(dst.tolist())

# Inicializa Graphviz
dot = graphviz.Digraph('PetriNet', engine='sfdp', format='png')
dot.attr(overlap='false', splines='true')

# Agrega sólo los nodos activos
for idx in sorted(active):
    ntype = int(torch.argmax(g.x[idx]).item())
    dot.node(str(idx), **node_kwargs[ntype])

# Agrega todas las aristas
for u, v in zip(src.tolist(), dst.tolist()):
    dot.edge(str(u), str(v))

# Renderiza
basename = os.path.join(output_folder,
                        os.path.splitext(os.path.basename(stitched_graph_file))[0])
dot.render(basename, cleanup=True)
print(f"✅ Visualización guardada en {basename}.png")
